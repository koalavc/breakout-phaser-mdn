/*
    <canvas> element automatically generated by the framework. 
    
    We are initializing it by creating a Phaser.Game object and assigning it to the game variable. 

    The parameters are 
        -   width and height set to the canvas
        -   the rendering method. the options are AUTO, CANVAS and WEBGL. We can set one of the latter two explicityly or use AUTO to let Phhase decide which one to use. It usually     uses WebGL if available in the browser, falling back to Canvas 2D if not.
        -   the id of the <canvas> to use for rendering if one already exists on the page (we've specified null because we want Phaser to create its own.)
        -   the names to use for Phaser's three key functions that load and start the game, and update the game loop on every frame; we will use the same names to keep it clean.
            -   preload takes care of preloading the assets
            -   create is executed once when everything is loaded and ready
            -   update is executed onn every frame.
*/ 

var game = new Phaser.Game(480, 320, Phaser.AUTO, null, {
    preload: preload, create: create, update: update
});

//Global variables
var ball;
// var ball2;
var paddle;
var bricks;
var newBrick;
var brickInfo;
var scoreText;
var score = 0;
var lives = 3;
var livesText;
var lifeLostText;
var playing = false;
var startButton;

function preload(){
    game.scale.ScaleMode = Phaser.ScaleManager.SHOW_ALL;
    game.scale.pageAlignHorizontally = true;
    game.scale.pageAlignVertically = true;
    
    /*
        Using the scale object in Phaser with a few methods and properties available. 
        
        scaleMode has a few different options for how Canvas can be scaled.
            -   NO_SCALE - nothing is scaled;
            -   EXACT_FIT - scale canvas to fill all the available space both vertically and horizontally
            -   SHOW_ALL - scales the canvas, but keeps the aspecct ratio untouched, so images won't be skewed. 
            -   RESIZE - creates the canvas with the same size as the available widht and height, so you have to place the objects inside your game dynamically; this is more of an advanced mode.
            -   USER_SCALE - allows you to have dynamic scaling, calculating the size, scale and ratio on your own, again, advanced mode.
    */

    // Adding background color to the canvas
    game.stage.backgroundColor = '#eee';

    /*
        first parameter we are assigning it to the name ball. then the sescond parameter to the relative path of the image.
    */ 
    game.load.image('ball', 'img/ball.png');
    // game.load.image('ball2', 'img/ball.png');
    game.load.image('paddle', 'img/paddle.png');
    game.load.image('brick', 'img/brick.png');
    game.load.spritesheet('ball', 'img/wobble.png', 20, 20);
    game.load.spritesheet('button', 'img/button.png', 120, 40);
    
}

function create() {
    // // we start our physics with start system
    // game.physics.startSystem(Phaser.Physics.ARCADE);
    // game.physics.arcade.checkCollision.down = false;

    // // to show it on the screen, we now use add.sprite method. this will add the ball to them game and render it on the screen.the first two paratmets are the x and y coordinates on the canvas where you want it to be added. third is the name of the asset we defined earlier.
    // ball = game.add.sprite(game.world.width*0.5, game.world.width-25, 'ball');
    // // ball2 = game.add.sprite(10, 60, 'ball2');
    // ball.anchor.set(0.5);
    // // using world.width and world.height to position the paddle exactly to where we want it to be.game.world.width*0.5 will be in the mdidle of the screen
    // // enabling the ball with the physics system
    // game.physics.enable(ball, Phaser.Physics.ARCADE);
    // // game.physics.enable(ball2, Phaser.Physics.ARCADE);
    // // allowing our ball to move on the screen , we can add velocity to its body
    // ball.body.velocity.set(150, -150);
    // // ball2.body.velocity.set(150, 150);
    // ball.body.collideWorldBounds = true;
    // // treating the boundaries of canvas as walls and not letting them move.
    // ball.body.bounce.set(1);
    // // ball2.body.collideWorldBounds = true;
    // // ball will now stop at the edge of the screen instead of falling off / disssappearing
    // ball.checkWorldBounds = true;
    
    // ball.events.onOutOfBounds.add(function () {
    //     alert('Game Over!');
    //     location.reload();
    // }, this);

    

    // // ball2.body.bounce.set(1);
    // paddle = game.add.sprite(game.world.width*0.5, game.world.height-5, 'paddle');
    // paddle.anchor.set(0.5,1);
    // game.physics.enable(paddle, Phaser.Physics.ARCADE);
    // paddle.body.immovable = true;
    
    game.physics.startSystem(Phaser.Physics.ARCADE);
    game.physics.arcade.checkCollision.down = false;
    ball = game.add.sprite(game.world.width * 0.5, game.world.height - 25, 'ball');
    ball.animations.add('wobble', [0, 1, 0, 2, 0, 1, 0, 2, 0], 24);
    ball.anchor.set(0.5);
    game.physics.enable(ball, Phaser.Physics.ARCADE);
    ball.body.collideWorldBounds = true;
    ball.body.bounce.set(1);
    ball.checkWorldBounds = true;
    ball.events.onOutOfBounds.add(ballLeaveScreen, this);

    paddle = game.add.sprite(game.world.width * 0.5, game.world.height - 5, 'paddle');
    paddle.anchor.set(0.5, 1);
    game.physics.enable(paddle, Phaser.Physics.ARCADE);
    paddle.body.immovable = true;

    initBricks();

    textStyle = {
        font: '18px Arial',
        fill: '#0095DD'
    };
    scoreText = game.add.text(5, 5, 'Points: 0', textStyle);
    livesText = game.add.text(game.world.width - 5, 5, 'Lives: ' + lives, textStyle);
    livesText.anchor.set(1, 0);
    lifeLostText = game.add.text(game.world.width * 0.5, game.world.height * 0.5, 'Life lost, tap to continue', textStyle);
    lifeLostText.anchor.set(0.5);
    lifeLostText.visible = false;

    startButton = game.add.button(game.world.width*0.5, game.world.height*0.5, 'button', startGame, this, 1, 0, 2);
    startButton.anchor.set(0.5);
}

/*
    brickInfo object will hold all the information we need: the width and height of a single brtick, the number of rows and columns of brick we see on the screen, the top and left offset(the location on the canvas where we start to draw the brick) and the padding between each row and column of bricks.


*/ 


function update(){

    // this code adds x and y properties representing our ball coordinates on the canvas. on each frame reload index.html and you should see the ball move across the screen.
    // ball.x += 1;
    // ball.y += 1;

    // this allows us to add collision detecction between the paddle and the ball
    game.physics.arcade.collide(ball, paddle, ballHitPaddle);
    game.physics.arcade.collide(ball, bricks, ballHitBrick);

    if(playing){
        paddle.x = game.input.x || game.world.width*0.5;
    }
    // now on every frame the paddle's x position will adjust accordingly to the x input's x position. however 
    paddle.x = game.input.x || game.world.width*0.5;
}

function initBricks() {
    brickInfo = {
        width: 50,
        height: 20,
        count: {
            row: 7,
            col: 3
        },
        offset: {
            top: 50,
            left: 60
        },
        padding: 10
    }

    bricks = game.add.group();


    /*
        Here we're looping through the rows and columns to cretae new bricks and place them on the screen. the newly created brick is enabled for the arcade physics enginge, it's bgody is set to be immovalble, (so it won't move when hit by the ball), and we're also setting the anchor to be in the middle and adding the brikc to the gorup.

        The problem is now that we are painting all the bricks in one place, at the coordinates (0,0). What we need to do ius tdraw eawch brick at it's own x and y position.
    */
    for (c = 0; c < brickInfo.count.col; c++) {
        for (r = 0; r < brickInfo.count.row; r++) {
            // create new brick and add it to the group


            /*
                Each brickX position is worked out as brickInfo.width plus brickInfo.padding, multiplied by the row number, r, plus the brickInfo.offset.left; 
                The logic for the brickY is identical except that it uses the values for column number, c, brickInfo.height, and brickInfo.offset.top

                Now every single brick can be placed in it's correct place, with padding between each brick, and drawn at an offset from the left and top Canvas edges.
            */
            var brickX = (r * (brickInfo.width + brickInfo.padding)) + brickInfo.offset.left;
            var brickY = (c * (brickInfo.height + brickInfo.padding)) + brickInfo.offset.top;
            newBrick = game.add.sprite(brickX, brickY, 'brick');
            game.physics.enable(newBrick, Phaser.Physics.ARCADE);
            newBrick.body.immovable = true;
            newBrick.anchor.set(0.5);
            bricks.add(newBrick);
        }
    }
}

function ballHitBrick(ball, brick){
    var killTween = game.add.tween(brick.scale);
    killTween.to({x:0,y:0}, 200, Phaser.Easing.Linear.None);
    killTween.onComplete.addOnce(function(){
        brick.kill();
    }, this);
    killTween.start();
    score += 10;
    scoreText.setText('Points: ' + score);

    //Win functionality

    /*
        We loop through the bricks in the group using bricks.children, checking for the aliveness of each with each bricks .alive() method. If there are no more bricks left alive, then we show a winning message, restarting the game once the alert is dismissed.
    */ 
    var count_alive = 0;
    for (i = 0; i < bricks.children.length; i++){
        if (bricks.children[i].alive == true){
            count_alive++;
        }
    }

    if (count_alive == 0){
        alert("You won the game, congradulations!!!!");
        location.reload();
    }
}


/**
 * Instead of instantly printing out the alert when you lose a life, we first substract one life from the current number and check if it's a non=-zero value. if yes, then the player still has some lives left and can continue to play - they will see the life lost message, the ball and paddle positions will be rset on screen and on the next input (click or touch) the messsage will be hidden and the ball will start to move again.
 * 
 * When the number of available lives reaches zero, the game is over and the game over alert message will be shown.
 */ 
function ballLeaveScreen(){
    lives--;
    if(lives){
        livesText.setText('Lives: '+lives);
        lifeLostText.visible = true;
        ball.reset(game.world.width*0.5, game.world.height-25);
        paddle.reset(game.world.width*0.5, game.world.height-5);
        game.input.onDown.addOnce(function(){
            lifeLostText.visible = false;
            ball.body.velocity.set(150, -150);
        }, this);
    }
    else {
        alert('You lost, game over!');
        location.reload();
    }
}

function ballHitPaddle(ball, paddle){
    ball.animations.play('wobble');
    ball.body.velocity.x = -1*5*(paddle.x-ball.x);
}

function startGame(){
    startButton.destroy();
    ball.body.velocity.set(150, -150);
    playing = true;
}